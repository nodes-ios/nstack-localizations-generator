//
//  GeneratorTestsData.swift
//  nstack-localizations-generator
//
//  Created by Marius Constantinescu on 29/05/2020.
//  Copyright © 2020 Nodes. All rights reserved.
//

import Foundation

struct GeneratorTestsData {
    static let jsonWithDefaultString = """
    {
      "data" : {
        "default" : {
          "successKey" : "Success"
        },
        "oneMoreSection" : {
          "soManyKeys" : "AndValues"
        }
      },
      "meta" : {
        "language" : {
          "direction" : "LRM",
          "id" : 11,
          "is_best_fit" : false,
          "is_default" : true,
          "locale" : "en-GB",
          "name" : "English (UK)"
        },
        "platform" : {
          "id" : 24,
          "slug" : "mobile"
        }
      }
    }
    """

    static let expectedCodeWithDefault = """
    // ----------------------------------------------------------------------\n// File generated by NStack Translations Generator.\n//\n// Copyright (c) 2018 Nodes ApS\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// ----------------------------------------------------------------------\n\nimport Foundation\n\n#if canImport(NLocalizationManager)\nimport NLocalizationManager\n#endif\n\n#if canImport(LocalizationManager)\nimport LocalizationManager\n#endif\n\npublic final class Localizations: LocalizableModel {\n    public var defaultSection = DefaultSection()\n    public var oneMoreSection = OneMoreSection()\n\n    enum CodingKeys: String, CodingKey {\n        case defaultSection = \"default\"\n        case oneMoreSection\n    }\n\n    public override init() { super.init() }\n\n    public required init(from decoder: Decoder) throws {\n        super.init()\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        defaultSection = try container.decodeIfPresent(DefaultSection.self, forKey: .defaultSection) ?? defaultSection\n        oneMoreSection = try container.decodeIfPresent(OneMoreSection.self, forKey: .oneMoreSection) ?? oneMoreSection\n    }\n\n    public override subscript(key: String) -> LocalizableSection? {\n        switch key {\n        case CodingKeys.defaultSection.stringValue: return defaultSection\n        case CodingKeys.oneMoreSection.stringValue: return oneMoreSection\n        default: return nil\n        }\n    }\n\n    public final class DefaultSection: LocalizableSection {\n        public var successKey = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case successKey\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            successKey = try container.decodeIfPresent(String.self, forKey: .successKey) ?? \"__successKey\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.successKey.stringValue: return successKey\n            default: return nil\n            }\n        }\n    }\n\n    public final class OneMoreSection: LocalizableSection {\n        public var soManyKeys = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case soManyKeys\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            soManyKeys = try container.decodeIfPresent(String.self, forKey: .soManyKeys) ?? \"__soManyKeys\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.soManyKeys.stringValue: return soManyKeys\n            default: return nil\n            }\n        }\n    }\n}\n\n
    """

    static let jsonWithoutDefaultString = """
    {
      "data" : {
        "oneMoreSection" : {
          "soManyKeys" : "AndValues"
        }
      },
      "meta" : {
        "language" : {
          "direction" : "LRM",
          "id" : 11,
          "is_best_fit" : false,
          "is_default" : true,
          "locale" : "en-GB",
          "name" : "English (UK)"
        },
        "platform" : {
          "id" : 24,
          "slug" : "mobile"
        }
      }
    }
    """

    static let expectedCodeWithoutDefault = """
    // ----------------------------------------------------------------------\n// File generated by NStack Translations Generator.\n//\n// Copyright (c) 2018 Nodes ApS\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// ----------------------------------------------------------------------\n\nimport Foundation\n\n#if canImport(NLocalizationManager)\nimport NLocalizationManager\n#endif\n\n#if canImport(LocalizationManager)\nimport LocalizationManager\n#endif\n\npublic final class Localizations: LocalizableModel {\n    public var oneMoreSection = OneMoreSection()\n\n    enum CodingKeys: String, CodingKey {\n        case oneMoreSection\n    }\n\n    public override init() { super.init() }\n\n    public required init(from decoder: Decoder) throws {\n        super.init()\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        oneMoreSection = try container.decodeIfPresent(OneMoreSection.self, forKey: .oneMoreSection) ?? oneMoreSection\n    }\n\n    public override subscript(key: String) -> LocalizableSection? {\n        switch key {\n        case CodingKeys.oneMoreSection.stringValue: return oneMoreSection\n        default: return nil\n        }\n    }\n\n    public final class OneMoreSection: LocalizableSection {\n        public var soManyKeys = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case soManyKeys\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            soManyKeys = try container.decodeIfPresent(String.self, forKey: .soManyKeys) ?? \"__soManyKeys\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.soManyKeys.stringValue: return soManyKeys\n            default: return nil\n            }\n        }\n    }\n}\n\n
    """

    static let jsonWithManyKeysAndSectionsString = """
    {
      "data" : {
        "default" : {
          "back" : "Tilbage",
          "cancel" : "Annuller",
          "dayBeforeYesterday" : "I forgårs",
          "done" : "Færdig",
          "edit" : "Rediger",
          "later" : "Senere",
          "next" : "Næste",
          "no" : "Nej",
          "ok" : "Ok",
          "okay" : "okay",
          "previous" : "Forrige",
          "retry" : "Prøv igen",
          "save" : "Gem",
          "settings" : "Indstillinger",
          "skip" : "Spring over",
          "today" : "I dag",
          "tomorrow" : "I morgen",
          "yes" : "Ja",
          "yesterday" : "I går"
        },
        "error" : {
          "authenticationError" : "Login er udløbet, login venligst ind igen.",
          "checkConnection" : "Tjek, at du har forbindelse til internettet, og prøv igen.",
          "connectionError" : "Ingen eller dårlig forbindelse, prøv igen.",
          "couldntGetContent" : "Kunne ikke hente indholdet",
          "errorTitle" : "Fejl",
          "getContent" : "Hent indhold",
          "unknownError" : "Ukendt fejl, prøv igen."
        },
        "history" : {
          "current" : "Aktuelle",
          "nothingToShow" : "Intet at vise",
          "noUpdates" : "Der er ingen opdateringer fra de sidste 30 dage.",
          "resolved" : "Løst sidste 30 dage",
          "title" : "Historik"
        },
        "incidents" : {
          "details" : "Detaljer",
          "latestUpdate" : "Seneste opdatering",
          "previousUpdates" : "Tidligere opdateringer"
        },
        "intro" : {
          "enableNotificationsConfirmButton" : "Slå til",
          "enableNotificationsDescription" : "Dette kan altid ændres senere i appens Indstillinger.",
          "enableNotificationsSkipButton" : "Spring over",
          "enableNotificationsTitle" : "Modtag notifikationer, når der er nye opdateringer",
          "gettingData" : "Henter data...",
          "info" : "Information",
          "introButtonText" : "Følg ministerier og styrelser",
          "introContent" : "Vælg, hvilke ministerområder og styrelser, du vil følge, så har du hurtig adgang til dem i appen.",
          "introHeader" : "Se driftsstatus der er relevant for dig",
          "introName" : "Driftsstatus",
          "messageHide" : "Skjul",
          "messageShow" : "Vis",
          "noInternet" : "Ingen internetforbindelse",
          "notificationPermissionErrorMessage" : "Du kan slå dem til ved at aktivere notifikationer i din telefons indstillinger.",
          "notificationPermissionErrorTitle" : "Notifikationer er slået fra i dine indstillinger",
          "overviewErrorButton" : "Hent driftsstatus",
          "overviewErrorMessage" : "Tjek, at du har forbindelse til internettet, og prøv igen.",
          "overviewErrorTitle" : "Kunne ikke hente driftsstatus",
          "overviewHistory" : "Se historik",
          "overviewNoItems" : "Ingen aktuelle driftsforstyrrelser",
          "overviewOffline" : "Offline",
          "overviewOnline" : "Online",
          "warning" : "Advarsel"
        },
        "message" : {
          "details" : "Detaljer",
          "typeError" : "Advarsel",
          "typeInformation" : "Information"
        },
        "ministrySelection" : {
          "deselectAllButton" : "Fjern alle",
          "followMinistriesTitle" : "Følg ministerier og styrelser",
          "ministryHeader" : "Ministerområde",
          "noneSelected" : "Ingen valgt",
          "selectAllButton" : "Vælg alle",
          "selectAtLeastOneMessage" : "Vælg mindst ét ministerområde eller styrelse for at fortsætte",
          "selectDepartmentsHeader" : "Vælg, hvilke styrelser du vil følge",
          "selectMinistriesHeader" : "Vælg ministerområde"
        },
        "settings" : {
          "about" : "Om appen",
          "availabilityReport" : "Tilgængelighedsrapporter",
          "contact" : "Kontakt",
          "followMinistries" : "Følg ministerier og styrelser",
          "followMinistriesDescription" : "Du vil se driftsstatus for de ministerområder og styrelser, du vælger at følge.",
          "notifications" : "Notifikationer",
          "notificationsDescription" : "Du vil modtage notifikationer, når der er ny driftsstatus, på områder du følger, eller når der er vigtig information og advarsler.",
          "notificationsPermissionButton" : "Til indstillinger",
          "notificationsPermissionDescription" : "Indstillinger for notifikationer styres fra iOS indstilinger.",
          "notificationsPermissionHeader" : "Notifikationsindstillinger",
          "settingsHeader" : "Indstillinger"
        }
      },
      "meta" : {
        "language" : {
          "direction" : "LRM",
          "id" : 6,
          "is_best_fit" : false,
          "is_default" : true,
          "locale" : "da-DK",
          "name" : "Danish"
        },
        "platform" : {
          "id" : 526,
          "slug" : "mobile"
        }
      }
    }
    """

    static let expectedCodeWithManyKeysAndSections = """
    // ----------------------------------------------------------------------\n// File generated by NStack Translations Generator.\n//\n// Copyright (c) 2018 Nodes ApS\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// ----------------------------------------------------------------------\n\nimport Foundation\n\n#if canImport(NLocalizationManager)\nimport NLocalizationManager\n#endif\n\n#if canImport(LocalizationManager)\nimport LocalizationManager\n#endif\n\npublic final class Localizations: LocalizableModel {\n    public var defaultSection = DefaultSection()\n    public var error = Error()\n    public var history = History()\n    public var incidents = Incidents()\n    public var intro = Intro()\n    public var message = Message()\n    public var ministrySelection = MinistrySelection()\n    public var settings = Settings()\n\n    enum CodingKeys: String, CodingKey {\n        case defaultSection = \"default\"\n        case error\n        case history\n        case incidents\n        case intro\n        case message\n        case ministrySelection\n        case settings\n    }\n\n    public override init() { super.init() }\n\n    public required init(from decoder: Decoder) throws {\n        super.init()\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        defaultSection = try container.decodeIfPresent(DefaultSection.self, forKey: .defaultSection) ?? defaultSection\n        error = try container.decodeIfPresent(Error.self, forKey: .error) ?? error\n        history = try container.decodeIfPresent(History.self, forKey: .history) ?? history\n        incidents = try container.decodeIfPresent(Incidents.self, forKey: .incidents) ?? incidents\n        intro = try container.decodeIfPresent(Intro.self, forKey: .intro) ?? intro\n        message = try container.decodeIfPresent(Message.self, forKey: .message) ?? message\n        ministrySelection = try container.decodeIfPresent(MinistrySelection.self, forKey: .ministrySelection) ?? ministrySelection\n        settings = try container.decodeIfPresent(Settings.self, forKey: .settings) ?? settings\n    }\n\n    public override subscript(key: String) -> LocalizableSection? {\n        switch key {\n        case CodingKeys.defaultSection.stringValue: return defaultSection\n        case CodingKeys.error.stringValue: return error\n        case CodingKeys.history.stringValue: return history\n        case CodingKeys.incidents.stringValue: return incidents\n        case CodingKeys.intro.stringValue: return intro\n        case CodingKeys.message.stringValue: return message\n        case CodingKeys.ministrySelection.stringValue: return ministrySelection\n        case CodingKeys.settings.stringValue: return settings\n        default: return nil\n        }\n    }\n\n    public final class DefaultSection: LocalizableSection {\n        public var back = \"\"\n        public var cancel = \"\"\n        public var dayBeforeYesterday = \"\"\n        public var done = \"\"\n        public var edit = \"\"\n        public var later = \"\"\n        public var next = \"\"\n        public var no = \"\"\n        public var ok = \"\"\n        public var okay = \"\"\n        public var previous = \"\"\n        public var retry = \"\"\n        public var save = \"\"\n        public var settings = \"\"\n        public var skip = \"\"\n        public var today = \"\"\n        public var tomorrow = \"\"\n        public var yes = \"\"\n        public var yesterday = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case back\n            case cancel\n            case dayBeforeYesterday\n            case done\n            case edit\n            case later\n            case next\n            case no\n            case ok\n            case okay\n            case previous\n            case retry\n            case save\n            case settings\n            case skip\n            case today\n            case tomorrow\n            case yes\n            case yesterday\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            back = try container.decodeIfPresent(String.self, forKey: .back) ?? \"__back\"\n            cancel = try container.decodeIfPresent(String.self, forKey: .cancel) ?? \"__cancel\"\n            dayBeforeYesterday = try container.decodeIfPresent(String.self, forKey: .dayBeforeYesterday) ?? \"__dayBeforeYesterday\"\n            done = try container.decodeIfPresent(String.self, forKey: .done) ?? \"__done\"\n            edit = try container.decodeIfPresent(String.self, forKey: .edit) ?? \"__edit\"\n            later = try container.decodeIfPresent(String.self, forKey: .later) ?? \"__later\"\n            next = try container.decodeIfPresent(String.self, forKey: .next) ?? \"__next\"\n            no = try container.decodeIfPresent(String.self, forKey: .no) ?? \"__no\"\n            ok = try container.decodeIfPresent(String.self, forKey: .ok) ?? \"__ok\"\n            okay = try container.decodeIfPresent(String.self, forKey: .okay) ?? \"__okay\"\n            previous = try container.decodeIfPresent(String.self, forKey: .previous) ?? \"__previous\"\n            retry = try container.decodeIfPresent(String.self, forKey: .retry) ?? \"__retry\"\n            save = try container.decodeIfPresent(String.self, forKey: .save) ?? \"__save\"\n            settings = try container.decodeIfPresent(String.self, forKey: .settings) ?? \"__settings\"\n            skip = try container.decodeIfPresent(String.self, forKey: .skip) ?? \"__skip\"\n            today = try container.decodeIfPresent(String.self, forKey: .today) ?? \"__today\"\n            tomorrow = try container.decodeIfPresent(String.self, forKey: .tomorrow) ?? \"__tomorrow\"\n            yes = try container.decodeIfPresent(String.self, forKey: .yes) ?? \"__yes\"\n            yesterday = try container.decodeIfPresent(String.self, forKey: .yesterday) ?? \"__yesterday\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.back.stringValue: return back\n            case CodingKeys.cancel.stringValue: return cancel\n            case CodingKeys.dayBeforeYesterday.stringValue: return dayBeforeYesterday\n            case CodingKeys.done.stringValue: return done\n            case CodingKeys.edit.stringValue: return edit\n            case CodingKeys.later.stringValue: return later\n            case CodingKeys.next.stringValue: return next\n            case CodingKeys.no.stringValue: return no\n            case CodingKeys.ok.stringValue: return ok\n            case CodingKeys.okay.stringValue: return okay\n            case CodingKeys.previous.stringValue: return previous\n            case CodingKeys.retry.stringValue: return retry\n            case CodingKeys.save.stringValue: return save\n            case CodingKeys.settings.stringValue: return settings\n            case CodingKeys.skip.stringValue: return skip\n            case CodingKeys.today.stringValue: return today\n            case CodingKeys.tomorrow.stringValue: return tomorrow\n            case CodingKeys.yes.stringValue: return yes\n            case CodingKeys.yesterday.stringValue: return yesterday\n            default: return nil\n            }\n        }\n    }\n\n    public final class Error: LocalizableSection {\n        public var authenticationError = \"\"\n        public var checkConnection = \"\"\n        public var connectionError = \"\"\n        public var couldntGetContent = \"\"\n        public var errorTitle = \"\"\n        public var getContent = \"\"\n        public var unknownError = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case authenticationError\n            case checkConnection\n            case connectionError\n            case couldntGetContent\n            case errorTitle\n            case getContent\n            case unknownError\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            authenticationError = try container.decodeIfPresent(String.self, forKey: .authenticationError) ?? \"__authenticationError\"\n            checkConnection = try container.decodeIfPresent(String.self, forKey: .checkConnection) ?? \"__checkConnection\"\n            connectionError = try container.decodeIfPresent(String.self, forKey: .connectionError) ?? \"__connectionError\"\n            couldntGetContent = try container.decodeIfPresent(String.self, forKey: .couldntGetContent) ?? \"__couldntGetContent\"\n            errorTitle = try container.decodeIfPresent(String.self, forKey: .errorTitle) ?? \"__errorTitle\"\n            getContent = try container.decodeIfPresent(String.self, forKey: .getContent) ?? \"__getContent\"\n            unknownError = try container.decodeIfPresent(String.self, forKey: .unknownError) ?? \"__unknownError\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.authenticationError.stringValue: return authenticationError\n            case CodingKeys.checkConnection.stringValue: return checkConnection\n            case CodingKeys.connectionError.stringValue: return connectionError\n            case CodingKeys.couldntGetContent.stringValue: return couldntGetContent\n            case CodingKeys.errorTitle.stringValue: return errorTitle\n            case CodingKeys.getContent.stringValue: return getContent\n            case CodingKeys.unknownError.stringValue: return unknownError\n            default: return nil\n            }\n        }\n    }\n\n    public final class History: LocalizableSection {\n        public var current = \"\"\n        public var noUpdates = \"\"\n        public var nothingToShow = \"\"\n        public var resolved = \"\"\n        public var title = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case current\n            case noUpdates\n            case nothingToShow\n            case resolved\n            case title\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            current = try container.decodeIfPresent(String.self, forKey: .current) ?? \"__current\"\n            noUpdates = try container.decodeIfPresent(String.self, forKey: .noUpdates) ?? \"__noUpdates\"\n            nothingToShow = try container.decodeIfPresent(String.self, forKey: .nothingToShow) ?? \"__nothingToShow\"\n            resolved = try container.decodeIfPresent(String.self, forKey: .resolved) ?? \"__resolved\"\n            title = try container.decodeIfPresent(String.self, forKey: .title) ?? \"__title\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.current.stringValue: return current\n            case CodingKeys.noUpdates.stringValue: return noUpdates\n            case CodingKeys.nothingToShow.stringValue: return nothingToShow\n            case CodingKeys.resolved.stringValue: return resolved\n            case CodingKeys.title.stringValue: return title\n            default: return nil\n            }\n        }\n    }\n\n    public final class Incidents: LocalizableSection {\n        public var details = \"\"\n        public var latestUpdate = \"\"\n        public var previousUpdates = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case details\n            case latestUpdate\n            case previousUpdates\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            details = try container.decodeIfPresent(String.self, forKey: .details) ?? \"__details\"\n            latestUpdate = try container.decodeIfPresent(String.self, forKey: .latestUpdate) ?? \"__latestUpdate\"\n            previousUpdates = try container.decodeIfPresent(String.self, forKey: .previousUpdates) ?? \"__previousUpdates\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.details.stringValue: return details\n            case CodingKeys.latestUpdate.stringValue: return latestUpdate\n            case CodingKeys.previousUpdates.stringValue: return previousUpdates\n            default: return nil\n            }\n        }\n    }\n\n    public final class Intro: LocalizableSection {\n        public var enableNotificationsConfirmButton = \"\"\n        public var enableNotificationsDescription = \"\"\n        public var enableNotificationsSkipButton = \"\"\n        public var enableNotificationsTitle = \"\"\n        public var gettingData = \"\"\n        public var info = \"\"\n        public var introButtonText = \"\"\n        public var introContent = \"\"\n        public var introHeader = \"\"\n        public var introName = \"\"\n        public var messageHide = \"\"\n        public var messageShow = \"\"\n        public var noInternet = \"\"\n        public var notificationPermissionErrorMessage = \"\"\n        public var notificationPermissionErrorTitle = \"\"\n        public var overviewErrorButton = \"\"\n        public var overviewErrorMessage = \"\"\n        public var overviewErrorTitle = \"\"\n        public var overviewHistory = \"\"\n        public var overviewNoItems = \"\"\n        public var overviewOffline = \"\"\n        public var overviewOnline = \"\"\n        public var warning = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case enableNotificationsConfirmButton\n            case enableNotificationsDescription\n            case enableNotificationsSkipButton\n            case enableNotificationsTitle\n            case gettingData\n            case info\n            case introButtonText\n            case introContent\n            case introHeader\n            case introName\n            case messageHide\n            case messageShow\n            case noInternet\n            case notificationPermissionErrorMessage\n            case notificationPermissionErrorTitle\n            case overviewErrorButton\n            case overviewErrorMessage\n            case overviewErrorTitle\n            case overviewHistory\n            case overviewNoItems\n            case overviewOffline\n            case overviewOnline\n            case warning\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            enableNotificationsConfirmButton = try container.decodeIfPresent(String.self, forKey: .enableNotificationsConfirmButton) ?? \"__enableNotificationsConfirmButton\"\n            enableNotificationsDescription = try container.decodeIfPresent(String.self, forKey: .enableNotificationsDescription) ?? \"__enableNotificationsDescription\"\n            enableNotificationsSkipButton = try container.decodeIfPresent(String.self, forKey: .enableNotificationsSkipButton) ?? \"__enableNotificationsSkipButton\"\n            enableNotificationsTitle = try container.decodeIfPresent(String.self, forKey: .enableNotificationsTitle) ?? \"__enableNotificationsTitle\"\n            gettingData = try container.decodeIfPresent(String.self, forKey: .gettingData) ?? \"__gettingData\"\n            info = try container.decodeIfPresent(String.self, forKey: .info) ?? \"__info\"\n            introButtonText = try container.decodeIfPresent(String.self, forKey: .introButtonText) ?? \"__introButtonText\"\n            introContent = try container.decodeIfPresent(String.self, forKey: .introContent) ?? \"__introContent\"\n            introHeader = try container.decodeIfPresent(String.self, forKey: .introHeader) ?? \"__introHeader\"\n            introName = try container.decodeIfPresent(String.self, forKey: .introName) ?? \"__introName\"\n            messageHide = try container.decodeIfPresent(String.self, forKey: .messageHide) ?? \"__messageHide\"\n            messageShow = try container.decodeIfPresent(String.self, forKey: .messageShow) ?? \"__messageShow\"\n            noInternet = try container.decodeIfPresent(String.self, forKey: .noInternet) ?? \"__noInternet\"\n            notificationPermissionErrorMessage = try container.decodeIfPresent(String.self, forKey: .notificationPermissionErrorMessage) ?? \"__notificationPermissionErrorMessage\"\n            notificationPermissionErrorTitle = try container.decodeIfPresent(String.self, forKey: .notificationPermissionErrorTitle) ?? \"__notificationPermissionErrorTitle\"\n            overviewErrorButton = try container.decodeIfPresent(String.self, forKey: .overviewErrorButton) ?? \"__overviewErrorButton\"\n            overviewErrorMessage = try container.decodeIfPresent(String.self, forKey: .overviewErrorMessage) ?? \"__overviewErrorMessage\"\n            overviewErrorTitle = try container.decodeIfPresent(String.self, forKey: .overviewErrorTitle) ?? \"__overviewErrorTitle\"\n            overviewHistory = try container.decodeIfPresent(String.self, forKey: .overviewHistory) ?? \"__overviewHistory\"\n            overviewNoItems = try container.decodeIfPresent(String.self, forKey: .overviewNoItems) ?? \"__overviewNoItems\"\n            overviewOffline = try container.decodeIfPresent(String.self, forKey: .overviewOffline) ?? \"__overviewOffline\"\n            overviewOnline = try container.decodeIfPresent(String.self, forKey: .overviewOnline) ?? \"__overviewOnline\"\n            warning = try container.decodeIfPresent(String.self, forKey: .warning) ?? \"__warning\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.enableNotificationsConfirmButton.stringValue: return enableNotificationsConfirmButton\n            case CodingKeys.enableNotificationsDescription.stringValue: return enableNotificationsDescription\n            case CodingKeys.enableNotificationsSkipButton.stringValue: return enableNotificationsSkipButton\n            case CodingKeys.enableNotificationsTitle.stringValue: return enableNotificationsTitle\n            case CodingKeys.gettingData.stringValue: return gettingData\n            case CodingKeys.info.stringValue: return info\n            case CodingKeys.introButtonText.stringValue: return introButtonText\n            case CodingKeys.introContent.stringValue: return introContent\n            case CodingKeys.introHeader.stringValue: return introHeader\n            case CodingKeys.introName.stringValue: return introName\n            case CodingKeys.messageHide.stringValue: return messageHide\n            case CodingKeys.messageShow.stringValue: return messageShow\n            case CodingKeys.noInternet.stringValue: return noInternet\n            case CodingKeys.notificationPermissionErrorMessage.stringValue: return notificationPermissionErrorMessage\n            case CodingKeys.notificationPermissionErrorTitle.stringValue: return notificationPermissionErrorTitle\n            case CodingKeys.overviewErrorButton.stringValue: return overviewErrorButton\n            case CodingKeys.overviewErrorMessage.stringValue: return overviewErrorMessage\n            case CodingKeys.overviewErrorTitle.stringValue: return overviewErrorTitle\n            case CodingKeys.overviewHistory.stringValue: return overviewHistory\n            case CodingKeys.overviewNoItems.stringValue: return overviewNoItems\n            case CodingKeys.overviewOffline.stringValue: return overviewOffline\n            case CodingKeys.overviewOnline.stringValue: return overviewOnline\n            case CodingKeys.warning.stringValue: return warning\n            default: return nil\n            }\n        }\n    }\n\n    public final class Message: LocalizableSection {\n        public var details = \"\"\n        public var typeError = \"\"\n        public var typeInformation = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case details\n            case typeError\n            case typeInformation\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            details = try container.decodeIfPresent(String.self, forKey: .details) ?? \"__details\"\n            typeError = try container.decodeIfPresent(String.self, forKey: .typeError) ?? \"__typeError\"\n            typeInformation = try container.decodeIfPresent(String.self, forKey: .typeInformation) ?? \"__typeInformation\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.details.stringValue: return details\n            case CodingKeys.typeError.stringValue: return typeError\n            case CodingKeys.typeInformation.stringValue: return typeInformation\n            default: return nil\n            }\n        }\n    }\n\n    public final class MinistrySelection: LocalizableSection {\n        public var deselectAllButton = \"\"\n        public var followMinistriesTitle = \"\"\n        public var ministryHeader = \"\"\n        public var noneSelected = \"\"\n        public var selectAllButton = \"\"\n        public var selectAtLeastOneMessage = \"\"\n        public var selectDepartmentsHeader = \"\"\n        public var selectMinistriesHeader = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case deselectAllButton\n            case followMinistriesTitle\n            case ministryHeader\n            case noneSelected\n            case selectAllButton\n            case selectAtLeastOneMessage\n            case selectDepartmentsHeader\n            case selectMinistriesHeader\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            deselectAllButton = try container.decodeIfPresent(String.self, forKey: .deselectAllButton) ?? \"__deselectAllButton\"\n            followMinistriesTitle = try container.decodeIfPresent(String.self, forKey: .followMinistriesTitle) ?? \"__followMinistriesTitle\"\n            ministryHeader = try container.decodeIfPresent(String.self, forKey: .ministryHeader) ?? \"__ministryHeader\"\n            noneSelected = try container.decodeIfPresent(String.self, forKey: .noneSelected) ?? \"__noneSelected\"\n            selectAllButton = try container.decodeIfPresent(String.self, forKey: .selectAllButton) ?? \"__selectAllButton\"\n            selectAtLeastOneMessage = try container.decodeIfPresent(String.self, forKey: .selectAtLeastOneMessage) ?? \"__selectAtLeastOneMessage\"\n            selectDepartmentsHeader = try container.decodeIfPresent(String.self, forKey: .selectDepartmentsHeader) ?? \"__selectDepartmentsHeader\"\n            selectMinistriesHeader = try container.decodeIfPresent(String.self, forKey: .selectMinistriesHeader) ?? \"__selectMinistriesHeader\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.deselectAllButton.stringValue: return deselectAllButton\n            case CodingKeys.followMinistriesTitle.stringValue: return followMinistriesTitle\n            case CodingKeys.ministryHeader.stringValue: return ministryHeader\n            case CodingKeys.noneSelected.stringValue: return noneSelected\n            case CodingKeys.selectAllButton.stringValue: return selectAllButton\n            case CodingKeys.selectAtLeastOneMessage.stringValue: return selectAtLeastOneMessage\n            case CodingKeys.selectDepartmentsHeader.stringValue: return selectDepartmentsHeader\n            case CodingKeys.selectMinistriesHeader.stringValue: return selectMinistriesHeader\n            default: return nil\n            }\n        }\n    }\n\n    public final class Settings: LocalizableSection {\n        public var about = \"\"\n        public var availabilityReport = \"\"\n        public var contact = \"\"\n        public var followMinistries = \"\"\n        public var followMinistriesDescription = \"\"\n        public var notifications = \"\"\n        public var notificationsDescription = \"\"\n        public var notificationsPermissionButton = \"\"\n        public var notificationsPermissionDescription = \"\"\n        public var notificationsPermissionHeader = \"\"\n        public var settingsHeader = \"\"\n\n        enum CodingKeys: String, CodingKey {\n            case about\n            case availabilityReport\n            case contact\n            case followMinistries\n            case followMinistriesDescription\n            case notifications\n            case notificationsDescription\n            case notificationsPermissionButton\n            case notificationsPermissionDescription\n            case notificationsPermissionHeader\n            case settingsHeader\n        }\n\n        public override init() { super.init() }\n\n        public required init(from decoder: Decoder) throws {\n            super.init()\n            let container = try decoder.container(keyedBy: CodingKeys.self)\n            about = try container.decodeIfPresent(String.self, forKey: .about) ?? \"__about\"\n            availabilityReport = try container.decodeIfPresent(String.self, forKey: .availabilityReport) ?? \"__availabilityReport\"\n            contact = try container.decodeIfPresent(String.self, forKey: .contact) ?? \"__contact\"\n            followMinistries = try container.decodeIfPresent(String.self, forKey: .followMinistries) ?? \"__followMinistries\"\n            followMinistriesDescription = try container.decodeIfPresent(String.self, forKey: .followMinistriesDescription) ?? \"__followMinistriesDescription\"\n            notifications = try container.decodeIfPresent(String.self, forKey: .notifications) ?? \"__notifications\"\n            notificationsDescription = try container.decodeIfPresent(String.self, forKey: .notificationsDescription) ?? \"__notificationsDescription\"\n            notificationsPermissionButton = try container.decodeIfPresent(String.self, forKey: .notificationsPermissionButton) ?? \"__notificationsPermissionButton\"\n            notificationsPermissionDescription = try container.decodeIfPresent(String.self, forKey: .notificationsPermissionDescription) ?? \"__notificationsPermissionDescription\"\n            notificationsPermissionHeader = try container.decodeIfPresent(String.self, forKey: .notificationsPermissionHeader) ?? \"__notificationsPermissionHeader\"\n            settingsHeader = try container.decodeIfPresent(String.self, forKey: .settingsHeader) ?? \"__settingsHeader\"\n        }\n\n        public override subscript(key: String) -> String? {\n            switch key {\n            case CodingKeys.about.stringValue: return about\n            case CodingKeys.availabilityReport.stringValue: return availabilityReport\n            case CodingKeys.contact.stringValue: return contact\n            case CodingKeys.followMinistries.stringValue: return followMinistries\n            case CodingKeys.followMinistriesDescription.stringValue: return followMinistriesDescription\n            case CodingKeys.notifications.stringValue: return notifications\n            case CodingKeys.notificationsDescription.stringValue: return notificationsDescription\n            case CodingKeys.notificationsPermissionButton.stringValue: return notificationsPermissionButton\n            case CodingKeys.notificationsPermissionDescription.stringValue: return notificationsPermissionDescription\n            case CodingKeys.notificationsPermissionHeader.stringValue: return notificationsPermissionHeader\n            case CodingKeys.settingsHeader.stringValue: return settingsHeader\n            default: return nil\n            }\n        }\n    }\n}\n\n
    """
}
